#!/usr/bin/env node

"use strict";

let fs = require("fs");
let path = require("path");
let yargs = require("yargs");

let arrays = require("../lib/utils/arrays");
let peg = require("../lib/peg");

/* Helpers */

function getVersionDescription() {
  return "PEG.js " + peg.VERSION;
}

function exitFailure() {
  process.exit(0);
}

function abort(message) {
  console.error(message);
  exitFailure();
}

function parseExtraOptions(options) {
  let extraOptions;

  try {
    extraOptions = JSON.parse(options);
  } catch (e) {
    if (!(e instanceof SyntaxError)) { throw e; }

    abort("Error parsing JSON: " + e.message);
  }

  if (typeof extraOptions !== "object") {
    abort("The JSON with extra options has to represent an object.");
  }

  return extraOptions;
}

function parseExtraOptionsFile(optionsFileName) {
  try {
    return parseExtraOptions(fs.readFileSync(optionsFileName));
  } catch(e) {
    abort("Can't read from file \"" + optionsFileName + "\".");
  }
}

function parseDependencyArray(dependencyArray) {
  if (!dependencyArray) return {};
  if (!Array.isArray(dependencyArray)) {
    dependencyArray = [dependencyArray];
  }
  return dependencyArray.reduce(function(dependencies, dependency) {
    if (dependency.indexOf(":") !== -1) {
      let parts = dependency.split(":");
      dependencies[parts[0]] = parts[1];
    } else {
      dependencies[dependency] = dependency;
    }
    return dependencies;
  }, {});
}

function parsePluginArray(pluginArray) {
  if (!pluginArray) return [];
  if (!Array.isArray(pluginArray)) {
    pluginArray = [pluginArray];
  }
  return pluginArray.map(function(plugin) {
    let id = /^(\.\/|\.\.\/)/.test(plugin) ? path.resolve(plugin) : plugin;
    let mod;
    try {
      mod = require(id);
    } catch (e) {
      if (e.code !== "MODULE_NOT_FOUND") { throw e; }

      abort("Can't load module \"" + id + "\".");
    }
    return mod;
  });
}

// Takes the last value from maybeArray if present
function takeLast(maybeArray) {
  if (!Array.isArray(maybeArray)) return maybeArray;
  return maybeArray[maybeArray.length - 1];
}

// Removes keys with undefined values from object
function filterUndefined(object) {
  Object.keys(object).forEach(function(key) {
    if (typeof object[key] === "undefined") {
      delete object[key];
    }
  });
}

/* Files */

function readStream(inputStream, callback) {
  let input = "";
  inputStream.on("data", function(data) { input += data; });
  inputStream.on("end", function() { callback(input); });
}

/* Parsing helpers */

// Using a function like this gives more flexibility than the
// requiresArg option in yargs
function requireArg(optionDesc, coerceFunc) {
  return function(arg) {
    if (typeof arg === 'undefined') {
      throw new Error("Missing parameter of the " + optionDesc + " option.")
    }
    if (coerceFunc) return coerceFunc(arg);
    return arg;
  }
}

/* Default options */

let defaultOptions = {
  cache: false,
  format: "commonjs",
  optimize: "speed",
  output: "source",
  trace: false
};

/* Options parsing */

let argv = yargs
  // Cause parsing to fail on unknown options
  .strict()
  // Stop help message from showing on parsing errors to preserve
  // the behaviour of previous versions
  .showHelpOnFail(false)
  .usage("Usage: $0 [options] [--] [<input_file>]")
  .option("allowed-start-rules", {
    type: "string",
    description: "comma-separated list of rules the generated parser will be allowed " +
                 "to start parsing from (default: the first rule in the grammar)",
    // Split the comma-separated rules into an array
    coerce: requireArg("--allowed-start-rules", function(rules) {
      function trim(str) {
        return str.trim();
      }
      return rules.split(",").map(trim);
    })
  })
  .option("cache", {
    type: "boolean",
    description: "make generated parser cache results (default: " + defaultOptions.cache + ")"
  })
  .option("d", {
    alias: "dependency",
    type: "string",
    description: "use specified dependency (can be specified multiple times)",
    coerce: requireArg("-d/--dependency")
  })
  .option("e", {
    alias: "export-var",
    type: "string",
    description: "name of a global variable into which the parser object is assigned " +
                 "to when no module loader is detected",
    coerce: requireArg("-e/--export-var")
  })
  .option("extra-options", {
    type: "string",
    description: "additional options (in JSON format) to pass to peg.generate",
    coerce: requireArg("--extra-options", parseExtraOptions)
  })
  .option("extra-options-file", {
    type: "string",
    description: "file with additional options (in JSON format) to pass to peg.generate",
    coerce: requireArg("--extra-options-file", parseExtraOptionsFile)
  })
  .option("format", {
    type: "string",
    description: "format of the generated parser (default: \"" + defaultOptions.format + "\")",
    choices: [
      "amd",
      "commonjs",
      "globals",
      "umd"
    ],
    coerce: requireArg("--format")
  })
  .help("h", "print help and exit")
  .alias("h", "help")
  .option("O", {
    alias: "optimize",
    type: "string",
    description: "select optimization for speed or size (default: \"" + defaultOptions.optimize + "\")",
    choices: [
      "speed",
      "size"
    ],
    coerce: requireArg("-O/--optimize")
  })
  .option("o", {
    alias: "output",
    type: "string",
    description: "output file",
    requiresArg: true,
    nargs: 1
  })
  .option("plugin", {
    type: "string",
    description: "use a specified plugin (can be specified multiple times)",
    requiresArg: true,
    nargs: 1
  })
  .option("trace", {
    type: "boolean",
    description: "enable tracing in the generated parser (default: " + defaultOptions.trace + ")"
  })
  .version("version", "print version information and exit", getVersionDescription)
  .alias("v", "version")
  .argv;

/* Options resolution */

let cliOptions = {
  cache: argv.cache,
  dependencies: parseDependencyArray(argv.dependency),
  exportVar: takeLast(argv.exportVar),
  format: takeLast(argv.format),
  optimize: takeLast(argv.optimize),
  output: "source",
  plugins: parsePluginArray(argv.plugin),
  trace: argv.trace
};

filterUndefined(cliOptions);

let options = Object.assign({},
  // Start with the default options
  defaultOptions,
  // Apply extra options file if present
  argv.extraOptionsFile || {},
  // Apply extra options JSON string if present
  argv.extraOptions || {},
  // Apply command line arguments on top
  cliOptions
);

if (
  Object.keys(options.dependencies).length > 0 &&
  !arrays.contains(["amd", "commonjs", "umd"], options.format)
) {
  abort("Can't use the -d/--dependency option with the \"" + options.format + "\" module format");
}

let inputFile = null;
let outputFile = argv.output || null;

let inputStream;
let outputStream;

switch (argv._.length) {
  case 0:
    inputFile = "-";
    break;

  case 1:
    inputFile = argv._[0];
    break;

  default:
    abort("Too many arguments.");
}

if (outputFile === null) {
  if (inputFile === "-") {
    outputFile = "-";
  } else {
    outputFile = inputFile.substr(0, inputFile.length - path.extname(inputFile).length) + ".js";
  }
}

if (inputFile === "-") {
  process.stdin.resume();
  inputStream = process.stdin;
  inputStream.on("error", function() {
    abort("Can't read from file \"" + inputFile + "\".");
  });
} else {
  inputStream = fs.createReadStream(inputFile);
}

if (outputFile === "-") {
  outputStream = process.stdout;
} else {
  outputStream = fs.createWriteStream(outputFile);
  outputStream.on("error", function() {
    abort("Can't write to file \"" + outputFile + "\".");
  });
}

/* Main */

readStream(inputStream, function(input) {
  let source;

  try {
    source = peg.generate(input, options);
  } catch (e) {
    if (e.location !== undefined) {
      abort(e.location.start.line + ":" + e.location.start.column + ": " + e.message);
    } else {
      abort(e.message);
    }
  }

  outputStream.write(source);
  if (outputStream !== process.stdout) {
    outputStream.end();
  }
});
